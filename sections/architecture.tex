\chapter{Architecture} \label{chap:architecture}

The aim of this Chapter is to depict \projName's architecture.
A high-level abstraction is presented in Figure~\ref{fig:system-architecture}, where each different component is represented together with the path data follows.
\projName has a client-server organization and each functionality is designed to be modular and self-contained for the ease of deployment, evaluation, scalability and availability.
On general lines, the server-side component is executed on untrusted machines (for instance nodes on the cloud) where Intel SGX is vailable.
On the remote end, the \sgxspark engine is deployed and stream processes the data generated by an arbitrary number of clients.
Each client is a sensor generating samples, and a gateway aggregating them and sending them periodically to the cloud-based component.
Similarly, clients fetch the results at fixed time intervals.
The interaction between the clients and the server happens over a filesystem interface hosted at the server-side.
Each client data stream is processed in parallel by the processing engine independently of the chosen algorithm.

The remaining of the chapter is structured as follows: \S\ref{sec:server} details the server-side architecture, \S\ref{sec:client} does the same with the client-side component, in \S\ref{sec:threat} we cover the considered threat model and the security assumptions we make in the design and lastly in \S\ref{sec:vulnerabilities} we present \projName's known vulnerabilities.

\begin{figure}[h!]
    \centering
    \input{figs/system-architecture.tex}
    \caption{(Left) Schematic of the system's main architecture. A set of clients bidirectionally stream data to a remote server. The interaction is done via a filesystem interface. On the server side, \sgxspark performs secure processing using different HRV analysis algorithms. (Right) Breakdown of a packaged client: itÂ includes a \texttt{sensor} and gateway that wrap four different microservices (\textsc{mqtt} broker, \texttt{mqtt-subscriber}, \texttt{consumer}, \texttt{producer}) to interact with the remote end. \label{fig:system-architecture}}
\end{figure}

\section{Server-Side} \label{sec:server}

The server-side component is made by three different modules: a filesystem interface, the \sgxspark engine, and a set of algorithms to analyze HRV. 
The filesystem interface acts as a landing point for the batches of data generated by each client. 
It is monitored by the \sgxspark engine.
Currently, it is mounted and unmounted, respectively at start-up time and upon the shutdown of the service. 
The streaming engine and the pool of algorithms are compiled together by the same toolchain, yet they are independent. 
The \textsc{Spark} engine (deployed in standalone mode) executes: the master process, the driver process, and an arbitrary number of workers. 
In the case of \sgxspark jobs, two JVMs are deployed per driver and worker process: one inside an enclave and one outside.
The communication between JVMs is kept encrypted and is done through the host OS shared memory (see Figure \ref{fig:sgx-spark-scheme}).
%the driver and the worker run in separated JVMs, isolated from each other.
%These JVMs are \emph{duplicated}, in the sense that the driver and each worker .
%Each JVM is, at the same time, duplicated\vs{what do you mean?}, with its counterpart running inside an enclave.
For each JVM pair, \sgxspark will initialize a new enclave.
% Being one located inside the enclave and another one outside. 
The specific algorithm that \projName will execute is currently set at start-up time, although several concurrent ones can be executed, each yielding separated results. 

\section{Clients} \label{sec:clients}

The client is a combination of: (1) a data generator that simulates a sensor and (2) a gateway that interacts with the remote end. 
The data generator streams RR intervals. %synthetic 
These samples are gathered by the gateway, which stacks and sends them for processing in a file-based streaming fashion. 
The typical size of these batches is in the 230---690 Bytes range.
Each gateway is composed by: a message broker that handles the samples, a service that handles data pre-processing and batch sending, and a fetcher that directly greps from the server's filesystem.

\section{Threat Model} \label{sec:threat}

We assume that the communication between the gateway and the filesystem is kept protected (\emph{e.g.}, encrypted) using secure transfer protocols (more in Section~\ref{sec:implementation}).
Given this assumption, \projName's threat model is the same as typical systems that rely on \textsc{SGX}. 
Specifically, we assume the system software is  untrusted.
Our security perimeter only includes the internals of the CPU package. 
The trusted computing base is Intel's microcode as well as and the code loaded at the enclave, which can be measured and integrity checked. 
In \projName, we assume that the client package is trusted and tamper-proof.
We focus on protecting the areas \emph{outside} user's control. 
However, if the client package is deployed in, for instance, a \textsc{Raspberry Pi}, the TCB could be further reduced using .

\section{Known Vulnerabilities} \label{sec:vulnerabilities}

As for the known vulnerabilities, \textsc{SGX} (in particular the memory encryption engine) is not designed to be an oblivious RAM.
As a consequence and adversary can perform traffic analysis attacks~\cite{Gueron2016}.
Moreover, side-channel attacks~\cite{sgx-sidechannel} and speculative execution attacks (\textit{Spectre}-like~\cite{sgx-spectre} and \textit{Foreshadow}~\cite{foreshadow}) have still successful against enclaves and will require in-silicon fixes.
