\chapter{Architecture} \label{chap:architecture}

The aim of this Chapter is to depict \projName's architecture.
A high-level abstraction is presented in Figure~\ref{fig:system-architecture}, where each different component is represented together with the path data follows.
\projName follows a client-server organization and each functionality is designed to be modular and self-contained for the ease of deployment, evaluation, scalability and availability.

On general lines, the server-side component is executed on untrusted machines (for instance nodes on the cloud) where Intel SGX is available.
There, the \sgxspark engine is deployed and stream processes the data generated by an arbitrary number of clients using a set of medical algorithms.
Each client consists of a sensor and a gateway: the former generates samples in a continuous fashion, and the latter aggregates them and periodically sends them to the cloud-based component.
Similarly, the gateway fetches the results every fixed time intervals.
A filesystem is mounted at the server-side to inferface the interaction between the clients and the processing engine.
Each client data stream is processed in parallel independently of the chosen algorithm and results are also stored separately.

The remaining of the chapter is structured as follows: \S\ref{sec:server} details the server-side architecture, \S\ref{sec:clients} does the same with the client-side component, in \S\ref{sec:threat} we cover the considered threat model and the security assumptions we make in the design and lastly in \S\ref{sec:vulnerabilities} we present \projName's known vulnerabilities.

\begin{figure}[h!]
    \centering
    \input{figs/system-architecture.tex}
    \caption{(Left) Schematic of the system's main architecture. A set of clients bidirectionally stream data to a remote server. The interaction is done via a filesystem interface. On the server side, \sgxspark performs secure processing using different HRV analysis algorithms. (Right) Breakdown of a packaged client: itÂ includes a \texttt{sensor} and gateway that wrap four different microservices (\textsc{mqtt} broker, \texttt{mqtt-subscriber}, \texttt{consumer}, \texttt{producer}) to interact with the remote end. \label{fig:system-architecture}}
\end{figure}

\section{Server-Side} \label{sec:server}

The server-side component is made by three different modules: a filesystem interface, the \sgxspark engine, and a set of algorithms to analyze HRV. 
The filesystem interface acts as a landing point for the batches of data generated by each client and also stores the algorithm results.
This way, the gateway can fetch with the desired frequency the processed information.
Currently, the filesystem is mounted and unmounted, respectively at start-up time and upon the shutdown of the service. 
\sgxspark monitors the directory and processes new data as it is loaded.

The streaming engine and the pool of algorithms are compiled together by the same toolchain, yet they are independent. 
A \textsc{Spark} job deployed in standalone mode executes: the master process for resource management and allocation (not included in Figure \ref{fig:system-architecture}), a driver process that orchestrates the exection, and an arbitrary number of worker processes executing tasks.
In the case of \sgxspark jobs, two Java Virtual Machines (JVMs) are deployed per driver and worker process: one inside an enclave and one outside.
The communication between \acrshort{jvm}s is kept encrypted and is done through the host OS shared memory (see Figure \ref{fig:sgx-spark-scheme}).
A process outside the enclave never sees data in clear since sensitive operations are \emph{always} executed in secured environments.
Note that, for each newly deployed worker, a new pair of \acrshort{jvm}s and a new enclave are deployed.

\sgxspark requires that algorithms are compiled together with the engine so that code can be loaded inside enclaves.
However, the specific algorithm that \projName will execute is currently set at start-up time.
It is important to note that each client has its own dedicated data stream assigned, hence being able to choose different algorithms.
These will be exececuted concurrently, each yielding separated results. 

\section{Clients} \label{sec:clients}

The client is a combination of: a sensor that constatnly generates data, and a gateway that interacts with the remote end (see the right hand side (RHS) of Figure \ref{fig:system-architecture}). 
For evaluation purposes, the sensor component is replaced by a synthetic data generator that simulates samples.
As introduced in \S\ref{sec:background:med} and depicted in Figure \ref{fig:ecg-hrv}, the samples produced correspond to RR intervals and their timestamps.
The data generator (or fake sensor) streams samples to the gateway which is composed of: a broker and subscriber that receive the samples, a producer that aggregates them, generates files of a fixed size, and streams them to the filesystem interface, and lastly a consumer that fetches the processed data from the remote endpoint. 
To get a grasp on the volume of data a single client generates, each sample is a couple of bytes and a healthy individual generates between 50 and 180 samples per minute.
As a consequence, an average client generates around 230---690 Bytes of data per minute.
This is indeed a low throughput but, as shown in Chapter \ref{chap:implementation}, \projName can withold way higher loads.

\section{Threat Model} \label{sec:threat}

We assume that the communication between the gateway and the filesystem is kept protected (\emph{e.g.}, encrypted) using secure transfer protocols (more in Section~\ref{sec:implementation}).
Given this assumption, \projName's threat model is the same as typical systems that rely on \textsc{SGX}. 
Specifically, we assume the system software is  untrusted.
Our security perimeter only includes the internals of the CPU package. 
The trusted computing base is Intel's microcode as well as and the code loaded at the enclave, which can be measured and integrity checked. 
In \projName, we assume that the client package is trusted and tamper-proof.
We focus on protecting the areas \emph{outside} user's control. 
However, if the client package is deployed in, for instance, a \textsc{Raspberry Pi}, the TCB could be further reduced using .

\section{Known Vulnerabilities} \label{sec:vulnerabilities}

As for the known vulnerabilities, \textsc{SGX} (in particular the memory encryption engine) is not designed to be an oblivious RAM.
As a consequence and adversary can perform traffic analysis attacks~\cite{Gueron2016}.
Moreover, side-channel attacks~\cite{sgx-sidechannel} and speculative execution attacks (\textit{Spectre}-like~\cite{sgx-spectre} and \textit{Foreshadow}~\cite{foreshadow}) have still successful against enclaves and will require in-silicon fixes.
