\chapter{Background} \label{chap:background}

In this chapter we introduce general concepts to better understand the design and implementation details of \projName.
Firstly, we introduce the hardware, software and programming frameworks that we leverage, and then the medical technicalities regarding the data we use and the processing we make of it.
In \S\ref{sec:background:tech}, we cover technical aspects exploited in the remaining of this paper, specifically: we descrive the concept of Trusted Execution Environment, the operating principles of Intel SGX and Spark, and lastly we present two key frameworks developed by the \textit{Large Scale Data \& Systems}~\cite{lsds} group at the Imperial College London, \textsc{SGX-LKL} and \sgxspark.
In \S\ref{sec:background:med}, we describe the specificities of the data streams that \projName has to deal with from the medical domain, how this data streams are obtained, together with the required processing that our system allows to offload on an untrusted cloud provider, and how this processing can be useful in a real use case.

\section{Technical Background} \label{sec:background:tech}

\subsection{Trusted Execution Environments and Intel SGX}
A \emph{trusted execution environment (TEE)} is an isolated area of a main processor that provides code and data therein contained with confidentiality and integrity guarantees~\cite{tee-globalplatform}. 
Condifentiality refers to preventing unauthorized parties from accessing sensitive information and integrity to ensuring that sensitive code and data is not tampered with.
An application developed to run and deployed in a TEE is called a \emph{Trusted Application (TA)}.
%The main CPU vendors have already implemented Trusted Execution Environments in their commodity CPUs.
Trusted Execution Environments have already been available for several years in the main CPU vendors' commodity CPUS.
\arm \tz has been part of \arm's architecture since v6 for Cortex-A processors (2012) and v8 for Cortex-M (2018).
Intel\textregistered\xspace \textsc{Software Guard Extensions (SGX)} were introduced with the sixth generation of Intel's processors codename \textit{Skylake} in 2015.

In comparison with \arm \tz, \textsc{Intel SGX} include a remote attestation protocol, support multiple trusted applications on the same CPU, its SDK is easier to program with, and there is a greater variety of programming frameworks to develop SGX-based TAs.
Most importantly, all the major Infrastructure-as-a-Service (IaaS) providers (Google~\cite{gceskylake}, Amazon~\cite{amazonskylake}, IBM~\cite{ibm-sgx}, Microsoft~\cite{azureconfidential}) are nowadays offering nodes with SGX processors.
For these reasons, \textsc{Intel SGX} is our chosen hardware solution to deploy \projName in.
\begin{wrapfigure}{r}{.5\textwidth}
    \centering
    \input{figs/sgx-principles.tex}
    \caption{\textsc{Intel SGX} execution workflow.\label{fig:sgx-principles}}
\end{wrapfigure}
Intel \textit{Software Guard eXtensions} are a set of new instructions and memory access changes added to Intel's architecture.
These extensions enable applications to create hardware-protected containers in their address space, referred to as \emph{enclaves}.
An enclave provides confidentiality and integrity even in the presence of malicious privileged software such as virtual machine monitors (VMM), BIOS or operating systems (OS)~\cite{sgx-whitepaper}. 
At initialization time, the code and data is free for inspection and, once loaded to the enclave, the latter is measured (via hashing) and sealed. 
An application using an enclave identifies itself through a remote attestation protocol and, once verified, interacts with the protected region through a call gate mechanism.
The application can also verify that its secure code is running in a genuine enclave using the same attestation protocol via platform specific keys. %The basic mechanisms of SGX are depicted in Figure~\ref{fig:sgx-principles}.

Services using SGX divide its source code in an untrusted and a trusted part.
The former deployed outside the enclve and the latter inside.
Figure~\ref{fig:sgx-principles} breaks down the typical execution workflow of SGX services.
After the initial attestation protocol, code in the untrusted region creates an enclave and securely loads trusted code and data inside (Figure-\ding{202}). 
Whenever this untrusted code wants to make use of the enclave, it makes a call to a trusted function (Figure-\ding{204}) that gets captured by the call gate mechanism and, after performing sanity and integrity checks (\ding{205}), gets executed (\ding{206}), the value returned (\ding{207}) and the untrusted code can resume execution (\ding{208}).
It is important to stress that the security perimeter is kept at the CPU package and, as a consequence, all other software including privileged software or even other enclaves are prevented from accessing code and data located inside the enclave. 
In particular, the systems' main memory is left untrusted and the traffic between CPU and DRAM over the protected address range is managed by the \textit{Memory Encryption Engine}~\cite{intel-mee}.
% TODO: should we mention SGX's main drawbacks or vulnerabilities?

\subsection{Spark and Spark Streaming}
\textsc{Apache Spark} is a cluster-computing framework to develop scalable, fault-tolerant, distributed applications. 
It builds on RDDs, resilient distributed datasets~\cite{spark-whitepaper}, a read-only collection distributed over a cluster that can be rebuilt if one partition is lost. 
It is implemented in \textsc{Scala} and provides bindings for \textsc{Python}, \textsc{Java}, \textsc{SQL} and \textsc{R}. 
\textsc{Spark Streaming}~\cite{spark-streaming} is an extension of Spark's core API that enables scalable, high-throughput, fault tolerant stream (mini-batch) processing of data streams~\cite{spark-streaming-documentation}.
\projName leverages Spark Streaming to perform file-based streaming, by monitoring a filesystem interface outside the enclave and processing new files as they are loaded.
In particular, and as detailed later in Chapter \ref{chap:implementation}, \projName uses the \textit{Structured Streaming} API.

\subsection{SGX-LKL and SGX-Spark}
Developed at the \textit{Large Scale Data \& Systems Group (LSDS)}~\cite{lsds} at the \textit{Imperial College London}, \textsc{SGX-LKL}~\cite{sgx-lkl} is a library OS to run unmodified Linux binaries inside enclaves.
It provides support for complex applications and managed runtimes enabling in-enclave user-level threading, signal handling, and paging.
Namely, it allows the execution of a full \textit{Java Virtual Machine (JVM)} inside an enclave. 
This feature enables the deployment of Spark, and Spark Streaming applications to leverage critical computing inside Intel SGX with minimal to no modifications to the application's code. 
\begin{wrapfigure}{r}{.5\textwidth}
    \centering
    \vspace{-21pt}
    \input{figs/sgx-spark.tex}
    \caption{\textsc{SGX-Spark} attacker model and collaborative structure scheme.\label{fig:sgx-spark-scheme}}
    \vspace{-19pt}
\end{wrapfigure}
\sgxspark~\cite{sgx-spark} builds on \textsc{SGX-LKL}.
It partitions the code of Spark applications to execute the sensitive parts inside SGX enclaves. 
Figure~\ref{fig:sgx-spark-scheme} depicts its architecture.
The engine deploys two collaborative Java Virtual Machines (JVM), one outside (Figure~\ref{fig:sgx-spark-scheme}, left) and one inside the enclave (Figure~\ref{fig:sgx-spark-scheme}, right) for the driver, and two more for each worker deployed in the cluster. 
Spark code outside the enclave accesses only encrypted data.
The communication between the JVMs is kept encrypted and is performed through the host OS shared memory.
\sgxspark provides a compilation toolchain, and it currently supports the vast majority of the native Spark operators, allowing to transparently deploy and run existing Spark applications into the SGX enclaves.
This is, the user must only compile the source code together with \textsc{SGX-Spark}'s and, as long as the operators used are supported by the framework, execution is seamlessly deployed inside the enclave with \emph{no} ammendments to the vanilla Spark implementation.

\section{Heart Rate Variability Analysis} \label{sec:background:med}
